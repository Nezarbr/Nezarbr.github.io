{"componentChunkName":"component---src-templates-blog-post-jsx","path":"/blog/my-second-blog/","result":{"data":{"site":{"siteMetadata":{"name":"Nezar Boujida","title":"Nezar Boujida | Data Scientist","description":null,"about":"I'm Nezar, a long-distance runner with a passion for traveling, discovery, and problem-solving. I’m studying Applied Mathematics and Computer Science at Sorbonne University, where I dive into data science, explore complex datasets, and uncover patterns.\n\nI've gained experience as a Data Scientist intern at Datategy and Hiflow, and now, I'm diving into the technical side as a Data Engineer intern at Launchmetrics. I enjoy sharing my journey through projects and discoveries, always eager to learn, grow.","author":null,"github":"https://github.com/Nezarbr","linkedin":"https://www.linkedin.com/in/nezar-boujida/"}},"markdownRemark":{"id":"89e3a90b-a838-5eb4-accb-6ebfb3d93ebd","excerpt":"Introduction In modern computational tasks, white noise generation and processing are fundamental in various fields, from signal processing to cryptography. The…","html":"<h2>Introduction</h2>\n<p>In modern computational tasks, white noise generation and processing are fundamental in various fields, from signal processing to cryptography. The process typically involves generating random noise, transforming it into the frequency domain using the Fast Fourier Transform (FFT), modifying the noise, and converting it back using the Inverse FFT (iFFT). However, such processes, especially when dealing with large datasets, can be computationally expensive and time-consuming.</p>\n<p>This article presents a study aimed at optimizing the execution time of white noise generation and FFT processing through the use of <strong>parallelization</strong> with OpenMP and <strong>vectorization</strong> with AVX2 instructions. The goal is to significantly reduce the computational load and improve performance. The following sections outline the problem statement, approach, and the resulting improvements from our optimization techniques.</p>\n<hr>\n<h2>Problem Statement</h2>\n<p>White noise generation and FFT operations involve significant computational effort, especially when processing large datasets like $2^{26}$ data points. In its raw form, white noise is inaudible but becomes more discernible after FFT and iFFT transformations. In applications that require real-time processing or frequent iterations over such large datasets, reducing the execution time is critical for performance.</p>\n<p>The initial version of the sequential code took approximately 70 seconds to execute, which was not practical for high-performance needs. The goal of this study was to identify computational bottlenecks, apply parallelization and vectorization techniques, and achieve substantial improvements in execution time.</p>\n<hr>\n<h2>Approach</h2>\n<p>We adopted a two-fold approach to optimize the execution time:</p>\n<h3>1. Parallelization with OpenMP</h3>\n<p>We identified key sections of the code for parallelization, primarily focusing on white noise generation, FFT calculations, and normalization.</p>\n<ul>\n<li>Using OpenMP directives, we distributed these tasks across multiple threads to exploit multi-core processors.</li>\n<li>For instance, the <code class=\"language-text\">#pragma omp parallel for</code> directive was applied to parallelize loops, and <code class=\"language-text\">#pragma omp task</code> was used for concurrent FFT operations, ensuring that independent tasks could be processed simultaneously.</li>\n</ul>\n<h3>2. Vectorization with AVX2</h3>\n<p>We utilized AVX2 intrinsics to vectorize the FFT-related calculations, allowing the CPU to perform operations on multiple data points in a single instruction cycle.</p>\n<ul>\n<li>The <code class=\"language-text\">FFT_rec()</code> function and complex number multiplication operations were vectorized to handle 256-bit wide registers (i.e., four double-precision floating-point numbers at once), leading to significant speedups in the computational heavy parts of the code.</li>\n</ul>\n<h3>3. Combining Parallelization and Vectorization</h3>\n<p>The final optimized code combined both parallelization and vectorization, ensuring that multi-core and SIMD (Single Instruction, Multiple Data) optimizations were used in harmony to maximize performance.</p>\n<hr>\n<h2>Results</h2>\n<p>The results of the optimizations were promising. The execution time of the original sequential code was reduced from 70 seconds to 10 seconds using a combination of OpenMP parallelization and AVX2 vectorization. The following performance improvements were achieved:</p>\n<ul>\n<li><strong>Parallelization with OpenMP</strong>: Reduced execution time from 70 seconds to 15 seconds, achieving a <strong>4.67x speedup</strong>.</li>\n<li><strong>Vectorization</strong>: Reduced execution time to 13.1 seconds, providing a <strong>5.34x speedup</strong>.</li>\n<li><strong>Combined Parallelization and Vectorization</strong>: Achieved the best performance, reducing the execution time to 10 seconds, yielding a <strong>7x speedup</strong>.</li>\n</ul>\n<p>These results highlight the effectiveness of applying both parallelization and vectorization techniques to reduce computational overhead in FFT-based white noise processing.</p>\n<hr>\n<h2>Conclusion</h2>\n<p>This study demonstrated how computational efficiency can be significantly improved through strategic parallelization and vectorization. By employing OpenMP and AVX2, we achieved a 7x improvement in execution time, making FFT-based white noise generation and processing more practical for high-performance applications.</p>\n<p>If you’re interested in exploring the full methodology and detailed results, you can download the complete paper <a href=\"/a731ae882d877ba58d5882cb89aa04d5/paper.pdf\">here</a>.</p>","frontmatter":{"title":"Enhancing Execution Speed of White Noise Generation through Parallelization and Vectorization","date":"January 11, 2024","description":"Accelerated FFT processing of white noise by leveraging OpenMP parallelization and AVX2 vectorization, significantly improving execution speed."}}},"pageContext":{"slug":"/blog/my-second-blog/","previous":{"fields":{"slug":"/blog/my-first-blog/"},"frontmatter":{"title":"Parallelization Strategies for Numerical Simulation of Heat Transfer in CPU Heatsinks"}},"next":{"fields":{"slug":"/blog/my-fourth-blog/"},"frontmatter":{"title":"Optimizing Automotive Logistics Enhancing Efficiency in Vehicle Transportation Services"}}}},"staticQueryHashes":["63159454"]}